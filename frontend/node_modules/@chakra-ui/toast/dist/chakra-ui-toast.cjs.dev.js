'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var system = require('@chakra-ui/system');
var React = require('react');
var alert = require('@chakra-ui/alert');
var closeButton = require('@chakra-ui/close-button');
var utils = require('@chakra-ui/utils');
var framerMotion = require('framer-motion');
var portal = require('@chakra-ui/portal');
var hooks = require('@chakra-ui/hooks');
var defaultTheme = require('@chakra-ui/theme');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);
var defaultTheme__default = /*#__PURE__*/_interopDefault(defaultTheme);

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

function getToastPlacement(position, dir) {
  var _logical$dir;

  var computedPosition = position != null ? position : "bottom";
  var logicals = {
    "top-start": {
      ltr: "top-left",
      rtl: "top-right"
    },
    "top-end": {
      ltr: "top-right",
      rtl: "top-left"
    },
    "bottom-start": {
      ltr: "bottom-left",
      rtl: "bottom-right"
    },
    "bottom-end": {
      ltr: "bottom-right",
      rtl: "bottom-left"
    }
  };
  var logical = logicals[computedPosition];
  return (_logical$dir = logical == null ? void 0 : logical[dir]) != null ? _logical$dir : computedPosition;
}

/**
 * Given an array of toasts for a specific position.
 * It returns the toast that matches the `id` passed
 */
/**
 * Given the toast manager state, finds the toast that matches
 * the id and return its position and index
 */

function findToast(toasts, id) {
  var position = getToastPosition(toasts, id);
  var index = position ? toasts[position].findIndex(function (toast) {
    return toast.id === id;
  }) : -1;
  return {
    position: position,
    index: index
  };
}
/**
 * Given the toast manager state, finds the position of the toast that
 * matches the `id`
 */

var getToastPosition = function getToastPosition(toasts, id) {
  var _Object$values$flat$f;

  return (_Object$values$flat$f = Object.values(toasts).flat().find(function (toast) {
    return toast.id === id;
  })) == null ? void 0 : _Object$values$flat$f.position;
};
/**
 * Gets the styles to be applied to a toast's container
 * based on its position in the manager
 */

function getToastStyle(position) {
  var isRighty = position.includes("right");
  var isLefty = position.includes("left");
  var alignItems = "center";
  if (isRighty) alignItems = "flex-end";
  if (isLefty) alignItems = "flex-start";
  return {
    display: "flex",
    flexDirection: "column",
    alignItems: alignItems
  };
}
/**
 * Compute the style of a toast based on its position
 */

function getToastListStyle(position) {
  var isTopOrBottom = position === "top" || position === "bottom";
  var margin = isTopOrBottom ? "0 auto" : undefined;
  var top = position.includes("top") ? "env(safe-area-inset-top, 0px)" : undefined;
  var bottom = position.includes("bottom") ? "env(safe-area-inset-bottom, 0px)" : undefined;
  var right = !position.includes("left") ? "env(safe-area-inset-right, 0px)" : undefined;
  var left = !position.includes("right") ? "env(safe-area-inset-left, 0px)" : undefined;
  return {
    position: "fixed",
    zIndex: 5500,
    pointerEvents: "none",
    display: "flex",
    flexDirection: "column",
    margin: margin,
    top: top,
    bottom: bottom,
    right: right,
    left: left
  };
}

var initialState = {
  top: [],
  "top-left": [],
  "top-right": [],
  "bottom-left": [],
  bottom: [],
  "bottom-right": []
};
/**
 * Store to track all the toast across all positions
 */

var toastStore = createStore(initialState);

function createStore(initialState) {
  var state = initialState;
  var listeners = new Set();

  var setState = function setState(setStateFn) {
    state = setStateFn(state);
    listeners.forEach(function (l) {
      return l();
    });
  };

  return {
    getState: function getState() {
      return state;
    },
    subscribe: function subscribe(listener) {
      listeners.add(listener);
      return function () {
        // Delete all toasts on unmount
        setState(function () {
          return initialState;
        });
        listeners["delete"](listener);
      };
    },

    /**
     * Delete a toast record at its position
     */
    removeToast: function removeToast(id, position) {
      setState(function (prevState) {
        var _extends2;

        return _extends({}, prevState, (_extends2 = {}, _extends2[position] = prevState[position].filter(function (toast) {
          return toast.id != id;
        }), _extends2));
      });
    },
    notify: function notify(message, options) {
      var toast = createToast(message, options);
      var position = toast.position,
          id = toast.id;
      setState(function (prevToasts) {
        var _prevToasts$position, _prevToasts$position2, _extends3;

        var isTop = position.includes("top");
        /**
         * - If the toast is positioned at the top edges, the
         * recent toast stacks on top of the other toasts.
         *
         * - If the toast is positioned at the bottom edges, the recent
         * toast stacks below the other toasts.
         */

        var toasts = isTop ? [toast].concat((_prevToasts$position = prevToasts[position]) != null ? _prevToasts$position : []) : [].concat((_prevToasts$position2 = prevToasts[position]) != null ? _prevToasts$position2 : [], [toast]);
        return _extends({}, prevToasts, (_extends3 = {}, _extends3[position] = toasts, _extends3));
      });
      return id;
    },
    update: function update(id, options) {
      if (!id) return;
      setState(function (prevState) {
        var nextState = _extends({}, prevState);

        var _findToast